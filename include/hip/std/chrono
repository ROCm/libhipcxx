//===----------------------------------------------------------------------===//
//
// Part of libcu++, the C++ Standard Library for your entire system,
// under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

// Modifications Copyright (c) 2024 Advanced Micro Devices, Inc.
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#ifndef _CUDA_CHRONO
#define _CUDA_CHRONO

#ifndef __HIPCC_RTC__
    #include <chrono>
#endif //__HIPCC_RTC__

#include "ctime"
#include "type_traits"
#include "ratio"
#include "limits"
#include "version"

#include "detail/__config"

#include "detail/__pragma_push"

// Silence NVCC warnings `long double` arising from chrono floating pointer
// user-defined literals which are defined in terms of `long double`.

// FIXME: There is currently no way to disable this diagnostic in a fine-grained
// fashion; if you include this header, the diagnostic will be suppressed
// throughout the translation unit. The alternative is loosing (conforming)
// chrono user-defined literals; this seems like the lesser of two evils, so...
#if defined(_LIBCUDACXX_COMPILER_NVCC)
#  if (CUDART_VERSION >= 11050)
#    pragma nv_diag_suppress cuda_demote_unsupported_floating_point
#  else
#    pragma diag_suppress cuda_demote_unsupported_floating_point
#  endif
#endif

#include "detail/libcxx/include/chrono"

_LIBCUDACXX_BEGIN_NAMESPACE_STD

namespace chrono {

#if defined(__HIP__) || defined(__HIPCC_RTC__)
#if _LIBCUDACXX_STD_VER>17 && defined(_LIBCUDACXX_EXPERIMENTAL_CHRONO_HIP)
// Workaround for system_clock on AMD GPUs for c++20, please see documentation in the below header file
#include "detail/libcxx/include/support/hip/chrono_hip_extension.h"
#endif
#endif

inline _LIBCUDACXX_INLINE_VISIBILITY
system_clock::time_point system_clock::now() _NOEXCEPT
{
#ifdef __CUDA_ARCH__
    uint64_t __time;
    asm volatile("mov.u64 %0, %%globaltimer;":"=l"(__time)::);
    return time_point(duration_cast<duration>(nanoseconds(__time)));
#elif defined(__HIP_DEVICE_COMPILE__) || defined(__HIPCC_RTC__)
#if _LIBCUDACXX_STD_VER>17 
#if defined(_LIBCUDACXX_EXPERIMENTAL_CHRONO_HIP)
    if(!(hip_gpu_ext::__unix_sysclock0>=0)) {
        // FIXME(HIP): As this function needs to be NOEXCEPT, we can't throw an exception at this point.
        printf("ERROR: Using sysclock on AMD GPUs requires a prior initialization call on the host side (hip::std::chrono::hip_gpu_ext::initialize_amdgpu_sysclock_on_current_device())."
             "The returned time point will not be a UNIX timestamp.\n");
    }
    // FIXME(HIP): This compilation path uses a workaround to make a UNIX timestamp counter available on the device.
    // see header "deatil/libcxx/include/support/hip/chrono_hip_extension.h" for more details. 
    assert(hip_gpu_ext::__unix_sysclock0>=0);
    long long __time = hip_gpu_ext::__unix_sysclock0 
                    + (wall_clock64()-hip_gpu_ext::__offset_devclock0);
    return time_point(duration_cast<duration>(chrono::duration<long long, ratio<1,_LIBCUDACXX_HIP_TSC_CLOCKRATE>>(__time)));
#else
    printf("WARNING: A C++20 standard-conform system_clock is currently only supported with an experimental workaround that can be "
           " activated with -D_LIBCUDACXX_EXPERIMENTAL_CHRONO_HIP compile flag (see detail/libcxx/include/support/hip/chrono_hip_extension.h)."
           "The returned time point will not be a UNIX timestamp.\n");
    // default HIP implementation C++20 without UNIX timestamp workaround
    // FIXME(HIP): Enable UNIX timestamps on the device without any workaround.
    long long __time = wall_clock64();
    return time_point(duration_cast<duration>(chrono::duration<long long, ratio<1,_LIBCUDACXX_HIP_TSC_CLOCKRATE>>(__time)));
#endif /*_LIBCUDACXX_EXPERIMENTAL_CHRONO_HIP*/
#else
    // FIXME(HIP): The timestamp on AMD devices will not be a UNIX timestamp. It is therefore different from the one on the host.
    // default HIP implementation
    long long __time = wall_clock64();
    return time_point(duration_cast<duration>(chrono::duration<long long, ratio<1,_LIBCUDACXX_HIP_TSC_CLOCKRATE>>(__time)));
#endif /*_LIBCUDACXX_STD_VER>17*/
#else
    return time_point(duration_cast<duration>(nanoseconds(
            ::std::chrono::duration_cast<::std::chrono::nanoseconds>(
                ::std::chrono::system_clock::now().time_since_epoch()
            ).count()
           )));
#endif
}

inline _LIBCUDACXX_INLINE_VISIBILITY
time_t system_clock::to_time_t(const system_clock::time_point& __t) _NOEXCEPT
{
    return time_t(duration_cast<seconds>(__t.time_since_epoch()).count());
}

inline _LIBCUDACXX_INLINE_VISIBILITY
system_clock::time_point system_clock::from_time_t(time_t __t) _NOEXCEPT
{
    return time_point(seconds(__t));;
}
}

_LIBCUDACXX_END_NAMESPACE_STD

#include "detail/__pragma_pop"

#endif //_CUDA_CHRONO


